// Generated by Bisonc++ V4.09.02 on Fri, 29 Apr 2016 13:37:05 +0200

#ifndef interpretParser_h_included
#define interpretParser_h_included

// $insert baseclass
#include "interpretParserbase.h"

#undef yyFlexLexer
#define yyFlexLexer interpretFlexLexer
	// forras: http://flex.sourceforge.net/manual/Cxx.html
		// ezen a modon a ket lexikalis elemzo (elsoparse, interpret) kulonbozo nevu lesz

#include "allapot.h"
#include "utils.h"

#include <FlexLexer.h>
#include <map>


#undef interpretParser
class interpretParser: public interpretParserBase
{
    public:
		interpretParser();
		~interpretParser();
		
		int completeParse(std::istream& in, int argsize);	// meghivja a preParse fv-t, majd a parse fv-t
			// az allapot kovetkezo utasitas valtozojat megfeleloen modositja (jmp -> ahova, kulonben ++ )
		
		void initAp(Allapot* ap, std::map<std::string, int> *uc);
		
		std::string get_error() const;
		
		enum Exceptions
		{
			HIBA,
		};

    private:
		int parse();
		void preParse(std::istream& in, int argsize);
	
		interpretFlexLexer *lexer;
		
		int argmeret;
		Allapot* allapot;	// kivulroladott, az gondoskodik a felszabaditasrol (ha egyaltalan dinamikusan van letrehozva)
		std::map<std::string, int> *ugrocimkek;
		
		std::string errorMsg;
	
        void error(char const *msg);    // called on (syntax) errors
        int lex();                      // returns the next token from the
                                        // lexical scanner. 
        void print();                   // use, e.g., d_token, d_loc

    // support functions for parse():
        void executeAction(int ruleNr);
        void errorRecovery();
        int lookup(bool recovery);
        void nextToken();
        void print__();
        void exceptionHandler__(std::exception const &exc);
};


#endif

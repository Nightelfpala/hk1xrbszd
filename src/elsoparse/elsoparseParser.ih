#ifndef ELSOPARSEPARSER_IH_INCLUDED
#define ELSOPARSEPARSER_IH_INCLUDED

#include "elsoparseParser.h"

inline elsoparseParser::elsoparseParser( std::istream &in) : lexer( &in, &std::cerr ), utasitasszam(0), elsoutasitas_cimke(""), errorMsg("")
{
	
}

inline elsoparseParser::~elsoparseParser()
{
	
}

inline std::map<int, utasitas_data> elsoparseParser::get_utasitasok() const
{
	return utasitas_gyujto;
}

inline std::map<std::string, int> elsoparseParser::get_valtozokezdet() const
{
	return valtozo_kezdetek;
}
inline std::map<std::string, int> elsoparseParser::get_ugrocimke() const
{
	return ugrocimke_kovutasitas;
}
	
inline std::vector<AP_UC> elsoparseParser::get_valtozok() const
{
	return valtozok;
}
	
inline std::string elsoparseParser::get_error() const
{
	return errorMsg;
}

inline void elsoparseParser::error(char const *msg)
{
	std::stringstream ss;
	ss << d_loc__.first_line << ". sor: " << msg << std::endl;
    errorMsg = ss.str();
}

inline int elsoparseParser::lex()
{
    d_loc__.first_line = lexer.lineno();
	int ret = lexer.yylex();
	if (ret == AZONOSITO or ret == SZAM or ret == REGISZTER or ret == KETARGUMENTUMOS or ret == EGYARGUMENTUMOS or ret == UGROUTAS)
	{
		d_val__.szoveg = new std::string(lexer.YYText());
	}
    return ret;
}

inline void elsoparseParser::print()         
{
    print__();
}

inline void elsoparseParser::exceptionHandler__(std::exception const &exc)		// http://bisoncpp.sourceforge.net/bisonc++06.html 6.3
{
	throw;  // re-implement to handle exceptions thrown by actions
}

int elsoparseParser::getRegSize(std::string reg)
{	// undefined behaviour with flag registers
	if (reg[0] == 'e')
	{
		return 4;
	} else if (reg[1] == 'p' || reg[1] == 'x')
	{
		return 2;
	} else
	{
		return 1;
	}
}


#endif